// Mutually recursive definitions which type check when partially annotated despite
// `t != u` and neither ex1a nor ex1b being generalized when ex1b is called within ex1a.
// To do this we need to initialize them with partially generalized types:
//   ex1a: forall t. t -> b1 -> r1
//   ex1b: forall u. u -> b2 -> r2
// Such that b1, b2, r1, and r2 can still be further refined.
ex1a (a: t) b =
    ex1b a b
    0u32

ex1b (a: u) b =
    ex1a a b
    1u32


// Second example
trait T1 a with trait1: fn a -> Unit
trait T2 a with trait2: fn a -> Unit

ex2a (a: t) b =
    ex2b a b
    trait1 a

ex2b (a: u) b =
    ex2c a b
    trait2 a

ex2c (a: v) b =
    ex2a a b

// args: -e ast-t
// expected stdout:
// (ex1a: fn t _ -> U32 can _) ((a: t)) (b: _) =
//     (ex1b: fn t _ -> U32 can _) (a: t) (b: _)
//     0_U32
// 
// (ex1b: fn u _ -> U32 can _) ((a: u)) (b: _) =
//     (ex1a: fn u _ -> U32 can _) (a: u) (b: _)
//     1_U32
// 
// trait T1 a with
//     (trait1: fn a {T1 a} -> Unit pure): fn a -> Unit
// 
// trait T2 a with
//     (trait2: fn a {T2 a} -> Unit pure): fn a -> Unit
// 
// (ex2a: fn t _ -> _ can _) ((a: t)) (b: _) =
//     (ex2b: fn t _ -> _ can _) (a: t) (b: _)
//     (trait1: (error)) (a: t)
// 
// (ex2b: fn u _ -> _ can _) ((a: u)) (b: _) =
//     (ex2c: fn u _ -> _ can _) (a: u) (b: _)
//     (trait2: (error)) (a: u)
// 
// (ex2c: fn v _ -> _ can _) ((a: v)) (b: _) =
//     (ex2a: fn v _ -> _ can _) (a: v) (b: _)

// expected stderr:
// examples/typechecking/mutual_recursion_rigid.an:22:4	error: `trait1` not found in scope
//     trait1 a
// 
// examples/typechecking/mutual_recursion_rigid.an:26:4	error: `trait2` not found in scope
//     trait2 a
// 
// Found 2 errors and 0 warnings

