
type Thing = nothing: Unit

trait Foo a with
    foo: fn a -> Unit

trait Bar a with
    bar: fn a -> Unit

trait Baz a with
    baz: fn a -> Unit

main () =
    // The call from which the `Foo a` constraint arises
    foo (Thing ())

// Candidate 1
impl candidate1 {_: Bar a}: Foo a with
    foo a = bar a

impl bar {_: Baz a}: Bar a with
    bar a = baz a

impl baz: Baz Thing with
    baz _ = ()


// Does not match
impl does_not_match {_: Print a}: Foo a with
    foo _ = ()


// Candidate 2
impl candidate2: Foo Thing with
    foo _ = ()

// args: --show-types
// expected stdout:
// type Thing =
//     nothing: Unit
// 
// trait Foo a with
//     (foo: _1): fn a -> Unit
// 
// trait Bar a with
//     (bar: _1): fn a -> Unit
// 
// trait Baz a with
//     (baz: _1): fn a -> Unit
// 
// (main: fn Unit -> _3) () =
//     (foo: (error)) ((Thing: fn Unit -> Thing) ())
// 
// impl candidate1 {(_: Bar a)}: (Foo: (error)) a with
//     (foo: fn a -> Unit) (a: a) = (bar: fn (Baz _3) -> Unit) (a: Baz _3)
// 
// impl bar {(_: Baz a)}: (Bar: (error)) a with
//     (bar: fn a -> Unit) (a: a) = (baz: fn a -> Unit) (a: a)
// 
// impl baz: (Baz: (error)) Thing with
//     (baz: fn Thing -> Unit) (_: Thing) = ()
// 
// impl does_not_match {(_: Print a)}: (Foo: (error)) a with
//     (foo: fn a -> Unit) (_: a) = ()
// 
// impl candidate2: (Foo: (error)) Thing with
//     (foo: fn Thing -> Unit) (_: Thing) = ()

// expected stderr:
// examples/typechecking/multiple_matching_impls.an:15:4	error: `foo` not found in scope
//     foo (Thing ())
// 
// examples/typechecking/multiple_matching_impls.an:19:12	error: Expected fn (Baz _3) -> Unit but found fn (Baz _3) -> Bar _3
//     foo a = bar a
// 
// examples/typechecking/multiple_matching_impls.an:19:16	error: Expected Baz _3 but found a
//     foo a = bar a
// 
// examples/typechecking/multiple_matching_impls.an:22:12	error: Expected fn _1 -> Unit but found Baz Thing
//     bar a = baz a
// 
// Found 4 errors and 0 warnings

